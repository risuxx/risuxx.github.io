<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C专家编程 | Risuxx's blog</title><meta name="description" content="C: 穿越时空的迷雾 它很棒，但它符合标准吗 不可移植代码 不同编译器定义不同的行为 未定义行为 标准中未规定的行为，这种行为编译器可以自己随意解释 可移植的代码 严格遵循标准的代码：只使用已确定的特性、不突破任何由编译器实现的限制、不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。 编译限制 ANSI C编译器需要支持：  函数定义中形参数量的上限至少可以达到31"><meta name="keywords" content="C"><meta name="author" content="Risuxx"><meta name="copyright" content="Risuxx"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="C专家编程"><meta name="twitter:description" content="C: 穿越时空的迷雾 它很棒，但它符合标准吗 不可移植代码 不同编译器定义不同的行为 未定义行为 标准中未规定的行为，这种行为编译器可以自己随意解释 可移植的代码 严格遵循标准的代码：只使用已确定的特性、不突破任何由编译器实现的限制、不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。 编译限制 ANSI C编译器需要支持：  函数定义中形参数量的上限至少可以达到31"><meta name="twitter:image" content="https://pic3.zhimg.com/80/v2-de49c5297197da2e6a544e39026aad8a_720w.jpg"><meta property="og:type" content="article"><meta property="og:title" content="C专家编程"><meta property="og:url" content="https://risuxx.github.io/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Risuxx's blog"><meta property="og:description" content="C: 穿越时空的迷雾 它很棒，但它符合标准吗 不可移植代码 不同编译器定义不同的行为 未定义行为 标准中未规定的行为，这种行为编译器可以自己随意解释 可移植的代码 严格遵循标准的代码：只使用已确定的特性、不突破任何由编译器实现的限制、不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。 编译限制 ANSI C编译器需要支持：  函数定义中形参数量的上限至少可以达到31"><meta property="og:image" content="https://pic3.zhimg.com/80/v2-de49c5297197da2e6a544e39026aad8a_720w.jpg"><meta property="article:published_time" content="2020-10-19T02:58:47.000Z"><meta property="article:modified_time" content="2020-11-09T05:41:06.660Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://risuxx.github.io/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"><link rel="prev" title="PPT" href="https://risuxx.github.io/2020/11/01/PPT/"><link rel="next" title="java-多线程" href="https://risuxx.github.io/2020/10/16/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-穿越时空的迷雾"><span class="toc-number">1.</span> <span class="toc-text">C: 穿越时空的迷雾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#它很棒但它符合标准吗"><span class="toc-number">1.1.</span> <span class="toc-text">它很棒，但它符合标准吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不可移植代码"><span class="toc-number">1.1.1.</span> <span class="toc-text">不可移植代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未定义行为"><span class="toc-number">1.1.2.</span> <span class="toc-text">未定义行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可移植的代码"><span class="toc-number">1.1.3.</span> <span class="toc-text">可移植的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译限制"><span class="toc-number">1.2.</span> <span class="toc-text">编译限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阅读ansi-c标准"><span class="toc-number">1.3.</span> <span class="toc-text">阅读ANSI C标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安静的改变究竟有多少安静"><span class="toc-number">1.4.</span> <span class="toc-text">“安静的改变”究竟有多少安静</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ada是什么"><span class="toc-number">1.4.0.0.0.1.</span> <span class="toc-text">Ada是什么？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#这不是bug而是语言特性"><span class="toc-number">2.</span> <span class="toc-text">这不是Bug，而是语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fall-through"><span class="toc-number">2.1.</span> <span class="toc-text">fall through</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多做之过"><span class="toc-number">2.1.1.</span> <span class="toc-text">多做之过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#误做之过"><span class="toc-number">2.1.2.</span> <span class="toc-text">误做之过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#少做之过"><span class="toc-number">2.1.3.</span> <span class="toc-text">少做之过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分析c语言的声明"><span class="toc-number">3.</span> <span class="toc-text">分析C语言的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#声明是如何形成的"><span class="toc-number">3.1.</span> <span class="toc-text">声明是如何形成的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举"><span class="toc-number">3.1.1.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过图表分析c语言的声明"><span class="toc-number">3.2.</span> <span class="toc-text">通过图表分析C语言的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef可以成为你的朋友"><span class="toc-number">3.3.</span> <span class="toc-text">typedef可以成为你的朋友</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解所有分析过程的代码段"><span class="toc-number">3.4.</span> <span class="toc-text">理解所有分析过程的代码段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#令人震惊的事实数组和指针并不相同"><span class="toc-number">4.</span> <span class="toc-text">令人震惊的事实：数组和指针并不相同</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是定义什么是声明"><span class="toc-number">4.1.</span> <span class="toc-text">什么是定义，什么是声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对链接的思考"><span class="toc-number">5.</span> <span class="toc-text">对链接的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态链接"><span class="toc-number">5.1.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#警惕interposition"><span class="toc-number">5.2.</span> <span class="toc-text">警惕Interposition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#产生链接器报告文件"><span class="toc-number">5.3.</span> <span class="toc-text">产生链接器报告文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运动的诗章运行时数据结构"><span class="toc-number">6.</span> <span class="toc-text">运动的诗章：运行时数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统在a.out文件里干了些什么"><span class="toc-number">6.1.</span> <span class="toc-text">操作系统在a.out文件里干了些什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto和static关键字"><span class="toc-number">6.2.</span> <span class="toc-text">auto和static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制线程"><span class="toc-number">6.3.</span> <span class="toc-text">控制线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setjmp和longjmp"><span class="toc-number">6.4.</span> <span class="toc-text">setjmp和longjmp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对内存的思考"><span class="toc-number">7.</span> <span class="toc-text">对内存的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存"><span class="toc-number">7.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cache存储器"><span class="toc-number">7.2.</span> <span class="toc-text">Cache存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏"><span class="toc-number">7.3.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sign.h有什么用"><span class="toc-number">7.3.0.0.0.1.</span> <span class="toc-text">sign.h有什么用？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么程序员无法分清万圣节和圣诞节"><span class="toc-number">8.</span> <span class="toc-text">为什么程序员无法分清万圣节和圣诞节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在等待时类型发生了变化"><span class="toc-number">8.1.</span> <span class="toc-text">在等待时类型发生了变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数也会被提升"><span class="toc-number">8.1.1.</span> <span class="toc-text">参数也会被提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型之痛"><span class="toc-number">8.2.</span> <span class="toc-text">原型之痛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用c语言实现有限状态机"><span class="toc-number">8.3.</span> <span class="toc-text">用C语言实现有限状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#混乱代码"><span class="toc-number">8.4.</span> <span class="toc-text">混乱代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#再论数组"><span class="toc-number">9.</span> <span class="toc-text">再论数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候数组与指针相同"><span class="toc-number">9.1.</span> <span class="toc-text">什么时候数组与指针相同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会发生混淆"><span class="toc-number">9.2.</span> <span class="toc-text">为什么会发生混淆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多维数组"><span class="toc-number">9.3.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#x-什么意思"><span class="toc-number">9.3.0.0.0.1.</span> <span class="toc-text">%#x 什么意思？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#再论指针"><span class="toc-number">10.</span> <span class="toc-text">再论指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多维数组的内存布局"><span class="toc-number">10.1.</span> <span class="toc-text">多维数组的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在锯齿状数组上使用指针"><span class="toc-number">10.2.</span> <span class="toc-text">在锯齿状数组上使用指针</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://pic3.zhimg.com/80/v2-de49c5297197da2e6a544e39026aad8a_720w.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Risuxx's blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">C专家编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-10-19 10:58:47"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-10-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-11-09 13:41:06"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-11-09</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="c-穿越时空的迷雾">C: 穿越时空的迷雾</h1>
<h2 id="它很棒但它符合标准吗">它很棒，但它符合标准吗</h2>
<h3 id="不可移植代码">不可移植代码</h3>
<p>不同编译器定义不同的行为</p>
<h3 id="未定义行为">未定义行为</h3>
<p>标准中未规定的行为，这种行为编译器可以自己随意解释</p>
<h3 id="可移植的代码">可移植的代码</h3>
<p>严格遵循标准的代码：只使用已确定的特性、不突破任何由编译器实现的限制、不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。</p>
<h2 id="编译限制">编译限制</h2>
<p>ANSI C编译器需要支持：</p>
<ul>
<li>函数定义中形参数量的上限至少可以达到31个</li>
<li>函数调用时实参数量的上限至少可以达到31个</li>
<li>在一条源代码行里至少可以有509个字符</li>
<li>在表达式中至少可以支持32层嵌套的括号</li>
<li>long int的最大值不得小于2147483647（不得低于32位）</li>
</ul>
<p>以上的这些并不是约束条件，也就是说当编译器发现违反了这些条件也不会报错。</p>
<h2 id="阅读ansi-c标准">阅读ANSI C标准</h2>
<p>赋值形式合法，必须满足下列条件之一：</p>
<p>两个操作数都是指向有限定符或者没有限定符的相容类型的指针；左边的指针所指向的类型必须具有右边的指针所指向的类型的全部限定符。</p>
<p>Both operands are pointers to qualified or unqualified versions of compatible types, and the type pointed to by the left has all the qualifiers of the type pointed to by the right.</p>
<p><code>const char ** p</code>是一个指向<code>char *</code>类型的常量指针（常量指针也就是<code>char *</code>这个指针是一个常量不能被修改）。</p>
<p>const用来限定函数的形参，进行限定之后该函数就不会修改实参指针所指向的数据，但是其他的函数却可能会修改它。</p>
<h2 id="安静的改变究竟有多少安静">“安静的改变”究竟有多少安静</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">23</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">204</span>, <span class="number">99</span>, <span class="number">16</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> d= <span class="number">-1</span>, x;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line"> <span class="keyword">if</span> (d &lt;= TOTAL_ELEMENTS<span class="number">-2</span>)</span><br><span class="line"> x = <span class="built_in">array</span>[d+<span class="number">1</span>]; </span><br><span class="line"><span class="comment">/* ... */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ANSI C中因为<code>sizeof</code>返回一个<code>unsigned int</code>类型，在<code>if</code>语句中<code>d</code>被升级为<code>unsigned int</code>类型（Otherwise, if either operand has type unsigned int, the other operand is converted to unsigned int），因此它编程了一个非常巨大的正整数，致使表达式的值为假。</p>
<h6 id="ada是什么">Ada是什么？</h6>
<p>Ada is a structured, statically typed, imperative, and object-oriented high-level programming language, extended from Pascal and other languages.</p>
<h1 id="这不是bug而是语言特性">这不是Bug，而是语言特性</h1>
<h2 id="fall-through">fall through</h2>
<p>case语句不加break的时候，就会依次执行下去。</p>
<p>break不会跳出if语句，而是会 跳出最近的那层循环语句或者switch语句。</p>
<p>相邻的字符串会自动合并，例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello world!"</span></span><br><span class="line"><span class="string">"you are welcome"</span>;</span><br><span class="line"><span class="comment">//s会被赋值为“hello world!You are welcome”</span></span><br></pre></td></tr></table></figure>
<p>者在字符串数组初始化的时候会引来错误信息。</p>
<p>下面的程序会使得第一次调用<code>generate_initializer</code>和之后调用它得到的结果不同。第一次会以<code></code>开头，而之后会用<code>,</code>开头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">generate_initializer(<span class="keyword">char</span> * <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line"> static char separator='';</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">"%c %s \n"</span>, separator, <span class="built_in">string</span>);</span><br><span class="line"> separator = <span class="string">','</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多做之过">多做之过</h3>
<p>在缺省的情况下函数的名字是全局可见的，可以在函数的名字前添加<code>extern</code>关键词，实际上没有添加这个关键词也是一样的效果，假如要限制这个函数的可见性则要使用关键词<code>static</code>进行修饰。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> function <span class="title">turnip</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//在这个文件之外不可见</span></span><br></pre></td></tr></table></figure>
<p>该特性会与C语言的另外一个特性组合起来造成影响。另一个特性叫做<code>interpositioning</code>，该特性允许用户编写和库函数同名的函数并取而代之。</p>
<p>C语言中对于一个函数你只能选择它是全局可见还是全局不可见，而不能指定对哪些文件可见对哪些不可见。也就是all-or-nothing</p>
<h3 id="误做之过">误做之过</h3>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201024125818081.png" alt="image-20201024125818081" style="zoom:80%;"></p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201024132731455.png" alt="image-20201024132731455" style="zoom:80%;"> <img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201024132756931.png" alt="image-20201024132756931" style="zoom:80%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = f() + g() * h();</span><br></pre></td></tr></table></figure>
<p>在上述表达式中，乘法一定会在加法之前进行，但是不能确定的是<code>f()</code>,<code>g()</code>,<code>h()</code>的计算顺序，它们之间以任何顺序进行都是合法的。</p>
<h3 id="少做之过">少做之过</h3>
<p>就是指语言应该提供但是没有提供的特性。</p>
<p>C语言中不能返回局部变量，因为局部变量通常分配在栈中，所以返回之后只是返回一个指向栈的地址，谁也不知道那个地址上会存什么内容。</p>
<p>解决这个问题的方案：</p>
<ol type="1">
<li>返回一个指向字符串常量的指针</li>
<li>使用全局声明的数组</li>
<li>使用静态数组 <code>static char buffer[20];</code></li>
<li>显式分配一些内存，保存返回的值 <code>char * s = malloc(120);</code></li>
<li>最好的解决方案就是要求调用者分配内存来保存函数的返回值。为了提高安全性，调用者应该同时指定缓冲区的大小。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="keyword">char</span> * result, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">strncpy</span>(result,<span class="string">"That'd be in the data segment, Bob"</span>,</span><br><span class="line"><span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">func( <span class="built_in">buffer</span>, <span class="built_in">size</span> );</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure>
<h1 id="分析c语言的声明">分析C语言的声明</h1>
<h2 id="声明是如何形成的">声明是如何形成的</h2>
<h3 id="枚举">枚举</h3>
<p>枚举（enum）将一串名字与一串整型值联系在一起。</p>
<p><code>#define</code>定义的名字一般在编译时被丢弃，而枚举名字则通常一直在调试器中可见，可以在调试代码时使用它们。</p>
<h2 id="通过图表分析c语言的声明">通过图表分析C语言的声明</h2>
<p><code>char * const * (*next)();</code> next是一个指向函数的指针，该函数返回另一个指针，该指针指向一个只读的指向char的指针</p>
<p><code>char * (* c[10])(int **p);</code> c是一个数组[0..9]，它的元素类型是函数指针，其所指向的函数的返回值是一个指向char的指针</p>
<h2 id="typedef可以成为你的朋友">typedef可以成为你的朋友</h2>
<p>一般情况下，<code>typedef</code>用于简洁地表示指向其他东西的指针。</p>
<p><code>void (*func)(int);</code>它表示一个函数指针，所指向的函数接受一个<code>int</code>参数，返回值是<code>void</code></p>
<p><code>void(*signal())(int)</code>其中signal是一个函数，它返回一个函数指针，然后这个函数指针所指向的函数接受一个<code>int</code>参数并返回<code>void</code></p>
<p><code>typedef</code>声明别名之后不能进行扩展:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> banana;</span><br><span class="line"><span class="keyword">unsigned</span> banana i; <span class="comment">//错误，非法！</span></span><br></pre></td></tr></table></figure>
<h2 id="理解所有分析过程的代码段">理解所有分析过程的代码段</h2>
<p>设计方案：使用一个堆栈，从左向右读取，把每个标记依次压入堆栈，直到读到标识符为止。然后我们继续向右读入一个标记，也就是标识符右边的那个标记。接着，观察标识符左边的那个标记（该标记需要从弹出）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTOKENLEN 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTOKENS 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> type_tag&#123; TYPE, QUALIFIER, IDENTIFIER&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> type; <span class="comment">//type包括type、qualifier、indentifier以及如*、(、[等特殊符号</span></span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">string</span>[MAXTOKENLEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存第一个标识之前的所有标记</span></span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> <span class="title">stack</span>[<span class="title">MAXTOKENS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存刚刚读入的那个标记</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> <span class="title">this_token</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop() stack[top--]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push(s) stack[++top] = s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实用程序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串分类，通过this_token.type返回一个值</span></span><br><span class="line"><span class="comment">// 该值为type类型、qualifier限定符或indentifier标识符</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> type_tag <span class="title">classify_string</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *s = this_token.<span class="built_in">string</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"const"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">strncpy</span>(s, <span class="string">"只读"</span>, <span class="number">5</span>);  <span class="comment">//不知道为什么只读后面会多打印一个空格？？？</span></span><br><span class="line">		<span class="keyword">return</span> QUALIFIER;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"volatile"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> QUALIFIER;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"void"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"char"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"signed"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"unsigned"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"short"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"int"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"long"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"float"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"double"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"struct"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"union"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"enum"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> TYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> IDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取标记，把下一个标记读入this_token.string</span></span><br><span class="line"><span class="comment">// 如果它是字母数字组合，调用classify_string</span></span><br><span class="line"><span class="comment">// 否则它必然是一个单字符标记，this.type=该标记</span></span><br><span class="line"><span class="comment">// 用一个nul结束this_token.string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_token</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 利用指针来修改string字符串</span></span><br><span class="line">	<span class="keyword">char</span> *p = this_token.<span class="built_in">string</span>;</span><br><span class="line">	<span class="comment">// 跳过空格</span></span><br><span class="line">	<span class="keyword">while</span> ((*p = getchar()) == <span class="string">' '</span>) &#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断是否是A-Z,0-9</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isalnum</span>(*p)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">isalnum</span>(*++p = getchar()))</span><br><span class="line">		&#123;</span><br><span class="line">			;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 假如是A-Z,0-9这些字符就直接写入string</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 假如不是这些字符就将getchar()读取出来的字符放回标准输入流</span></span><br><span class="line">		ungetc(*p, <span class="built_in">stdin</span>);</span><br><span class="line">		<span class="comment">// 然后将刚才被getchar()获得的字符修改的string的那个位置写成NUL</span></span><br><span class="line">		*p = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="comment">// 因为不是特殊字符，所以类型必为type、qualifier、indentifier中的一个</span></span><br><span class="line">		this_token.type = classify_string();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于指针</span></span><br><span class="line">	<span class="keyword">if</span> (*p == <span class="string">'*'</span>) &#123;</span><br><span class="line">		<span class="built_in">strncpy</span>(this_token.<span class="built_in">string</span>, <span class="string">"指针，该指针指向"</span>, <span class="number">17</span>); <span class="comment">// 因为中文的表达习惯这里暂时用@标记，标识 指向...的指针</span></span><br><span class="line">		this_token.type = <span class="string">'*'</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于其他特殊符号</span></span><br><span class="line">	this_token.<span class="built_in">string</span>[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	this_token.type = *p;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取至第一个标识符，调用get_token把标记压入堆栈中</span></span><br><span class="line"><span class="comment">// 直到遇见第一个标识符，之后继续调用get_token</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_to_first_identifier</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	get_token();</span><br><span class="line">	<span class="keyword">while</span> (this_token.type != IDENTIFIER) &#123;</span><br><span class="line">		push(this_token);</span><br><span class="line">		get_token();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s是"</span>, this_token.<span class="built_in">string</span>);</span><br><span class="line">	get_token();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数参数</span></span><br><span class="line"><span class="comment">// 当读取越过右括号后，打印函数返回...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_with_function_args</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (this_token.type != <span class="string">')'</span>) &#123;</span><br><span class="line">		get_token();</span><br><span class="line">	&#125;</span><br><span class="line">	get_token();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"函数，该函数返回"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数数组</span></span><br><span class="line"><span class="comment">// 当读取[size]后将其打印并且继续向右读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_with_arrays</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (this_token.type == <span class="string">'['</span>) &#123;</span><br><span class="line">		get_token(); <span class="comment">// 可能是数字或者]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组"</span>)；</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(this_token.<span class="built_in">string</span>[<span class="number">0</span>])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0..%d"</span>, atoi(this_token.<span class="built_in">string</span>) - <span class="number">1</span>);</span><br><span class="line">			get_token(); <span class="comment">// 读取]</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 要输出...的数组 例如类型为char的函数指针数组</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"，该数组类型是"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理任何指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_with_pointers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">stack</span>[top].type == <span class="string">'*'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>, pop().<span class="built_in">string</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_with_declarator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (this_token.type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'['</span>: deal_with_arrays();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'('</span>: deal_with_function_args();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deal_with_pointers();</span><br><span class="line">	<span class="keyword">while</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stack</span>[top].type == <span class="string">'('</span>) &#123;</span><br><span class="line">			pop();</span><br><span class="line">			get_token();</span><br><span class="line">			deal_with_declarator();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s "</span>, pop().<span class="built_in">string</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	read_to_first_identifier();</span><br><span class="line">	deal_with_declarator();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="令人震惊的事实数组和指针并不相同">令人震惊的事实：数组和指针并不相同</h1>
<p>确实存在一种指针和数组的定义完全相同的上下文环境，但是这只是数组的一种极为普通的用法，并非所有情况下都是如此。</p>
<h2 id="什么是定义什么是声明">什么是定义，什么是声明</h2>
<p>C语言中的对象必须 有且只有一个定义，但是它可以有多个extern声明。定义是一种特殊的声明，它创建了要给对象，而声明只是告诉我们在其他的地方创建过这个对象，把那个对象的名字重新说一遍，并允许你使用这个名字。所谓定义就是要为该对象分配内存。</p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030151020820.png"></p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030151028318.png"></p>
<p>使用指针需要多一个额外的提取，但是它更加灵活。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"abcdefgh"</span>; ... p[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>取得符号表中的p的地址，提取存储于此处的指针</li>
<li>把下标所表示的偏移量与指针的值相加，从而得到一个新地址</li>
<li>访问上面的这个地址，取得字符</li>
</ol>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030151606478.png"></p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030151616726.png"></p>
<p>使用指针初始化的字符串，通常会被放在只读的文本段中。但是由字符串常量初始化的数组是可以被修改的。其中的单个字符在以后可以改变。</p>
<h1 id="对链接的思考">对链接的思考</h1>
<h2 id="动态链接">动态链接</h2>
<p>动态链接必须保证4个特定的函数库libc（C运行时函数库）、libsys（其他系统函数）、libX（X windowing）、libnsl（网络服务）</p>
<p>静态库使用<code>ar</code>进行链接，动态库使用<code>ld</code>进行链接。</p>
<p><code>.so</code>表示shared object，是动态库文件的扩展名</p>
<p><code>.a</code>是静态库文件的扩展名</p>
<p>可以通过选项告诉编译应该链接的函数库的完整名称，例如<code>-lthread</code>表示编译连接到<code>libthread.so</code>，<code>-lname</code>表示链接到<code>libname.so</code></p>
<p>编译器<code>-Lpathname</code>和<code>-Rpathname</code>用来告诉链接器一些其他的目录。</p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030155955391.png"></p>
<p>在缺省状态下链接器会在<code>/usr/ccs/lib</code>和<code>/usr/lib</code>中查找函数库中的符号</p>
<p>函数库选项：应该始终将<code>-l</code>函数库选项放在编译命令行的最右边</p>
<h2 id="警惕interposition">警惕Interposition</h2>
<p>Interposition也就是使用同样名称的用户函数去代替标准的库函数</p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030162353671.png"></p>
<h2 id="产生链接器报告文件">产生链接器报告文件</h2>
<p>在<code>ld</code>程序中使用<code>-m</code>选项，会让链接器产生一个报告。该报告包括了被Interpose的符号的说明。</p>
<p><code>ld</code>程序 中的<code>-D</code>允许用户显示链接-编辑过程和所包含的输入文件。</p>
<h1 id="运动的诗章运行时数据结构">运动的诗章：运行时数据结构</h1>
<p>a.out: assembler output</p>
<ol type="1">
<li>数据段保存在目标文件中</li>
<li>ss段不保存在目标文件中（除了记录BSS段在运行时所需的大小）</li>
<li>文本段最容易收到优化措施影响</li>
<li>a.out文件的大小受调试状态下编译的影响，但段不受影响</li>
</ol>
<h2 id="操作系统在a.out文件里干了些什么">操作系统在a.out文件里干了些什么</h2>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030170235926.png" alt="image-20201030170235926" style="zoom:80%;"></p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201030171220410.png" alt="image-20201030171220410" style="zoom:80%;"></p>
<h2 id="auto和static关键字">auto和static关键字</h2>
<p>使用<code>static</code>关键字，那么变量就会被分配在数据段中，而不是在堆栈中。auto表示在进入该块后，自动分配存储，在函数的内部声明的数据默认就是这种分配方式，它几乎不在实际中使用。</p>
<h2 id="控制线程">控制线程</h2>
<p>在进程中要支持不同的控制线程依赖的是使用不同的堆栈，每个线程的堆栈为1Mb（当有需要的时候可以增长）在每个线程的堆栈之间有个一个red zone页。（这个红色区域（red zone）就是一个优化。因为这个区域不会被信号或者中断侵占，函数可以在不移动栈指针的情况下使用它存取一些临时数据——于是两个移动rsp的指令就被节省下来了）</p>
<h2 id="setjmp和longjmp">setjmp和longjmp</h2>
<p>会使用setjmp来设置一个需要跳转的label，然后使用longjmp来跳转。它相比goto可以跳转到更远的地方，goto只能在函数内部跳转。需要使用头文件<code>&lt;setjmp.h&gt;</code></p>
<h1 id="对内存的思考">对内存的思考</h1>
<p>所有的磁盘制造商都是使用十进制数而不是二进制数来表示磁盘的容量。2GB是2000000000个字节而不是217483648个字节</p>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201107163506286.png" alt="image-20201107163506286" style="zoom:80%;"> <img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201107163515830.png" alt="image-20201107163515830" style="zoom:80%;"></p>
<h2 id="虚拟内存">虚拟内存</h2>
<p>交换区在磁盘上，一般而言交换区的大小是物理内存的几倍。内核是常驻内存的，一般只有用户进程才会被换进换出。</p>
<h2 id="cache存储器">Cache存储器</h2>
<p>Cache的操作速度与系统的周期时间相同。因此50MHz的处理器，Cache的存取周期为20ns。</p>
<h2 id="内存泄漏">内存泄漏</h2>
<p>可以使用<code>alloca()</code>来分配动态内存，但是该方法不适合在生命期更长的结构中使用。</p>
<p>在链表中释放元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span>, *<span class="title">start</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">for</span>(p = start; p; p = tmp)&#123;</span><br><span class="line">    tmp = p -&gt; next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sign.h有什么用">sign.h有什么用？</h6>
<p>https://en.wikipedia.org/wiki/C_signal_handling</p>
<h1 id="为什么程序员无法分清万圣节和圣诞节">为什么程序员无法分清万圣节和圣诞节</h1>
<h2 id="在等待时类型发生了变化">在等待时类型发生了变化</h2>
<h3 id="参数也会被提升">参数也会被提升</h3>
<p>在被调用函数的内部，提升后的参数会被裁减为原先声明的大小。例如在使用<code>printf</code>的时候，<code>%d</code>会默认取出<code>int</code>类型的参数，也就是说假如使用它去打印<code>long long</code>的值则会发生问题。</p>
<h2 id="原型之痛">原型之痛</h2>
<p>建立原型的目的就是消除一种普通（但是很难被发现）的错误，就是形参和实参之间类型不匹配。</p>
<p><code>int ioctl(int fd, ind cmd, …)；</code> 其中fd是用户程序打开设备时使用open函数返回的文件标示符，cmd是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。 ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道。</p>
<h2 id="用c语言实现有限状态机">用C语言实现有限状态机</h2>
<p>大多是有限状态机基于函数指针数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*state[MAX_STATES])();</span><br><span class="line">extern int a(), b(), c(), d();</span><br><span class="line"><span class="keyword">int</span> (*state[])() = &#123; a, b, c, d &#125;; </span><br><span class="line"><span class="comment">// A function can be called through a pointer in the array like this: </span></span><br><span class="line">(*state[i])();</span><br></pre></td></tr></table></figure>
<p>cdecl as an FSM</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTOKENS 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTOKENLEN 64</span></span><br><span class="line"><span class="keyword">enum</span> type_tag &#123; IDENTIFIER, QUALIFIER, TYPE &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> type;</span><br><span class="line"> <span class="keyword">char</span> <span class="built_in">string</span>[MAXTOKENLEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* holds all the tokens before first identifier */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> <span class="title">stack</span>[<span class="title">MAXTOKENS</span>];</span></span><br><span class="line"><span class="comment">/* holds the token just read */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> <span class="title">this</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop stack[top--]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push(s) stack[++top]=s</span></span><br><span class="line"><span class="keyword">enum</span> type_tag</span><br><span class="line">classify_string(<span class="keyword">void</span>)</span><br><span class="line">    <span class="comment">/* figure out the identifier type */</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">char</span> *s = <span class="keyword">this</span>.<span class="built_in">string</span>;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"const"</span>)) &#123;</span><br><span class="line"> <span class="built_in">strcpy</span>(s, <span class="string">"read-only"</span>);</span><br><span class="line"> <span class="keyword">return</span> QUALIFIER;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"volatile"</span>)) <span class="keyword">return</span> QUALIFIER;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"void"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"char"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"signed"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"unsigned"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"short"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"int"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"long"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"float"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"double"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"struct"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"union"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">"enum"</span>)) <span class="keyword">return</span> TYPE;</span><br><span class="line"> <span class="keyword">return</span> IDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gettoken</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* read next token into "this" */</span></span><br><span class="line"> <span class="keyword">char</span> *p = <span class="keyword">this</span>.<span class="built_in">string</span>;</span><br><span class="line"> <span class="comment">/* read past any spaces */</span></span><br><span class="line"> <span class="keyword">while</span> ((*p = getchar()) == <span class="string">' '</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">isalnum</span>(*p)) &#123;</span><br><span class="line"> <span class="comment">/* it starts with A-Z,1-9 read in identifier */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*++p = getchar()));</span><br><span class="line"> ungetc(*p, <span class="built_in">stdin</span>);</span><br><span class="line"> *p = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="keyword">this</span>.type = classify_string();</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">this</span>.<span class="built_in">string</span>[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="keyword">this</span>.type = *p;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">void initialize(),</span><br><span class="line"> get_array(), get_params(), get_lparen(),</span><br><span class="line">get_ptr_part(), get_type();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*nextstate)(<span class="keyword">void</span>) = initialize; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/* Cdecl written as a finite state machine */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* transition through the states, until the pointer</span></span><br><span class="line"><span class="comment">is null */</span></span><br><span class="line"> <span class="keyword">while</span> (nextstate != <span class="literal">NULL</span>)</span><br><span class="line"> (*nextstate)();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> gettoken();</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">this</span>.type != IDENTIFIER) &#123;</span><br><span class="line"> push(<span class="keyword">this</span>);</span><br><span class="line"> gettoken();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s is "</span>, <span class="keyword">this</span>.<span class="built_in">string</span>);</span><br><span class="line"> gettoken();</span><br><span class="line"> nextstate = get_array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> nextstate = get_params;</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">this</span>.type == <span class="string">'['</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"array "</span>);</span><br><span class="line"> gettoken();<span class="comment">/* a number or ']' */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(<span class="keyword">this</span>.<span class="built_in">string</span>[<span class="number">0</span>])) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"0..%d "</span>, atoi(<span class="keyword">this</span>.<span class="built_in">string</span>) - <span class="number">1</span>);</span><br><span class="line"> gettoken();<span class="comment">/* read the ']' */</span></span><br><span class="line"> &#125;</span><br><span class="line"> gettoken();<span class="comment">/* read next past the ']' */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"of "</span>);</span><br><span class="line"> nextstate = get_lparen;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_params</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> nextstate = get_lparen;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.type == <span class="string">'('</span>) &#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">this</span>.type != <span class="string">')'</span>) &#123;</span><br><span class="line"> gettoken();</span><br><span class="line"> &#125;</span><br><span class="line"> gettoken();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"function returning "</span>); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_lparen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> nextstate = get_ptr_part;</span><br><span class="line"> <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">stack</span>[top].type == <span class="string">'('</span>) &#123;</span><br><span class="line"> pop;</span><br><span class="line"> gettoken();<span class="comment">/* read past ')' */</span></span><br><span class="line"> nextstate = get_array;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ptr_part</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> nextstate = get_type;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">stack</span>[top].type == <span class="string">'*'</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pointer to "</span>);</span><br><span class="line"> pop;</span><br><span class="line"> nextstate = get_lparen;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">stack</span>[top].type == QUALIFIER) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s "</span>, pop.<span class="built_in">string</span>);</span><br><span class="line"> nextstate = get_lparen;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_type</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> nextstate = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="comment">/* process tokens that we stacked while reading to</span></span><br><span class="line"><span class="comment">identifier */</span></span><br><span class="line"> <span class="keyword">while</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s "</span>, pop.<span class="built_in">string</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>debugging hooks：可以编写一个函数用于遍历整个数据结构并把它打印出来，然后可以在调试的时候通过调试器命令行来调用该函数。</p>
<p>可调式性编码：先完成最简单的功能，然后逐步增加更加复杂的功能。</p>
<h2 id="混乱代码">混乱代码</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w printf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p while</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t(s) (W=T(s))</span></span><br><span class="line"><span class="keyword">char</span> *X,*B,*L,I[<span class="number">99</span>];M,W,V;D()&#123;W==<span class="number">9</span>?(w(<span class="string">"`%.*s' is"</span>,V,X),t(<span class="number">0</span>)):W==<span class="number">40</span>?</span><br><span class="line">(t(<span class="number">0</span>),D(),t(<span class="number">41</span>)):W==<span class="number">42</span>?(t(<span class="number">0</span>),D(),w(<span class="string">"ptr to "</span>)):<span class="number">0</span>;p(W==<span class="number">40</span>?(t(<span class="number">0</span>),</span><br><span class="line">w(<span class="string">"func returning "</span>),t(<span class="number">41</span>)):W==<span class="number">91</span>?(t(<span class="number">0</span>)==<span class="number">32</span>?(w(<span class="string">"array[0..%d]</span></span><br><span class="line"><span class="string">of "</span>,</span><br><span class="line">atoi(X)<span class="number">-1</span>),t(<span class="number">0</span>)):w(<span class="string">"array of "</span>),t(<span class="number">93</span>)):<span class="number">0</span>);&#125;main()&#123;p(w(<span class="string">"input:</span></span><br><span class="line"><span class="string">"</span>),</span><br><span class="line">B=gets(I))<span class="keyword">if</span>(t(<span class="number">0</span>)==<span class="number">9</span>)L=X,M=V,t(<span class="number">0</span>),D(),w(<span class="string">"%.*s.\n\n"</span>,M,L);&#125;T(s)</span><br><span class="line">&#123;<span class="keyword">if</span>(!s||s==W)</span><br><span class="line">&#123;p(*B==<span class="number">9</span>||*B==<span class="number">32</span>)B++;X=B;V=<span class="number">0</span>;<span class="keyword">if</span>(W=<span class="built_in">isalpha</span>(*B)?<span class="number">9</span>:<span class="built_in">isdigit</span>(*B)?<span class="number">32</span></span><br><span class="line">:*B++)</span><br><span class="line"><span class="keyword">if</span>(W&lt;<span class="number">33</span>)p(<span class="built_in">isalnum</span>(*B))B++,V++;&#125;<span class="keyword">return</span> W;&#125;</span><br></pre></td></tr></table></figure>
<p>该程序也就是之前的cdel程序，首先有两个子程序<code>T()</code>和<code>D()</code>，前者用来寻找下一个标记并确定它是标识符、数字还是其他东西，后者负责分析过程。三元符需要还原成if语句才能使该程序可读。</p>
<h1 id="再论数组">再论数组</h1>
<h2 id="什么时候数组与指针相同">什么时候数组与指针相同</h2>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201109123706934.png" alt="image-20201109123706934" style="zoom:80%;"></p>
<h2 id="为什么会发生混淆">为什么会发生混淆</h2>
<p>数组下标表达式总是可以改写为带偏移量的指针表达式。作为函数的参数的时候数组和指针是可以互换的，以及在表达式中它们是可以互换的。在表达式中<code>a[10]</code>很可能被翻译成<code>*(a+i)</code></p>
<h2 id="多维数组">多维数组</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> carrot[i][j];</span><br><span class="line"><span class="comment">// 被解释为</span></span><br><span class="line">*（*（carrot + i） + j）;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201109131001693.png"></p>
<p>只有字符串常量才可以初始化指针数组。</p>
<h6 id="x-什么意思">%#x 什么意思？</h6>
<p>The character % is followed by zero or more of the following flags:</p>
<p><strong>#</strong> The value should be converted to an ‘‘alternate form’’. For o conversions, the first character of the output string is made zero (by prefixing a 0 if it was not zero already). For x and X conversions, a non-zero result has the string ‘0x’ (or ‘0X’ for X conversions) prepended to it. For a, A, e, E, f, F, g, and G conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows). For g and G conversions, trailing zeros are not removed from the result as they would otherwise be. For other conversions, the result is undefined.</p>
<h1 id="再论指针">再论指针</h1>
<h2 id="多维数组的内存布局">多维数组的内存布局</h2>
<p><img src="/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/image-20201109133051250.png"></p>
<h2 id="在锯齿状数组上使用指针">在锯齿状数组上使用指针</h2>
<p>假如要保存的字符串长度不一，可以使用字符串指针数组来解决。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Risuxx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://risuxx.github.io/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/">https://risuxx.github.io/2020/10/19/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://risuxx.github.io" target="_blank">Risuxx's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="https://pic4.zhimg.com/80/v2-44243020fbff5630b343a4e92c3186fb_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/11/01/PPT/"><img class="prev_cover" src="https://pic4.zhimg.com/80/v2-b76becbb2b3049c8507293bd4dfbf8b7_720w.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PPT</div></div></a></div><div class="next-post pull_right"><a href="/2020/10/16/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next_cover" src="https://pic4.zhimg.com/80/v2-44243020fbff5630b343a4e92c3186fb_720w.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java-多线程</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Risuxx</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>