<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MIT_6.828 | Risuxx's blog</title><meta name="description" content="简介 MIT6.828 Operating System Engineering 6.828的目标是：1. 理解操作系统设计和实现、2. 实现小型操作系统 OS的目的是：1. 支持应用程序运行、2. 对硬件进行抽象、3. 在多个应用程序之间复用硬件、4. 隔离应用程序防止bugs、5. 允许共用多个应用程序、6. 高性能 操作系统内核一般提供：进程、内存分配、file contents、目"><meta name="keywords" content="os"><meta name="author" content="Risuxx"><meta name="copyright" content="Risuxx"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="MIT_6.828"><meta name="twitter:description" content="简介 MIT6.828 Operating System Engineering 6.828的目标是：1. 理解操作系统设计和实现、2. 实现小型操作系统 OS的目的是：1. 支持应用程序运行、2. 对硬件进行抽象、3. 在多个应用程序之间复用硬件、4. 隔离应用程序防止bugs、5. 允许共用多个应用程序、6. 高性能 操作系统内核一般提供：进程、内存分配、file contents、目"><meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-44243020fbff5630b343a4e92c3186fb_720w.jpg"><meta property="og:type" content="article"><meta property="og:title" content="MIT_6.828"><meta property="og:url" content="https://risuxx.github.io/2020/11/16/MIT-6-828/"><meta property="og:site_name" content="Risuxx's blog"><meta property="og:description" content="简介 MIT6.828 Operating System Engineering 6.828的目标是：1. 理解操作系统设计和实现、2. 实现小型操作系统 OS的目的是：1. 支持应用程序运行、2. 对硬件进行抽象、3. 在多个应用程序之间复用硬件、4. 隔离应用程序防止bugs、5. 允许共用多个应用程序、6. 高性能 操作系统内核一般提供：进程、内存分配、file contents、目"><meta property="og:image" content="https://pic4.zhimg.com/80/v2-44243020fbff5630b343a4e92c3186fb_720w.jpg"><meta property="article:published_time" content="2020-11-16T10:03:27.000Z"><meta property="article:modified_time" content="2020-12-01T12:30:07.850Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://risuxx.github.io/2020/11/16/MIT-6-828/"><link rel="next" title="angr-ctf" href="https://risuxx.github.io/2020/11/15/angr-ctf/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lab1-booting-a-pc"><span class="toc-number">2.</span> <span class="toc-text">Lab1: Booting a PC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">2.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#software-setup"><span class="toc-number">2.2.</span> <span class="toc-text">Software Setup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#simulating-the-x86"><span class="toc-number">2.2.1.</span> <span class="toc-text">Simulating the x86</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rom-bios"><span class="toc-number">2.3.</span> <span class="toc-text">ROM BIOS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#the-pcs-physical-address-space"><span class="toc-number">2.3.1.</span> <span class="toc-text">The PC&#39;s Physical Address Space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise2"><span class="toc-number">2.3.2.</span> <span class="toc-text">Exercise2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-2-the-boot-loader"><span class="toc-number">2.4.</span> <span class="toc-text">Part 2: The Boot Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise3"><span class="toc-number">2.4.1.</span> <span class="toc-text">Exercise3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gdb"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">GDB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loading-the-kernel"><span class="toc-number">2.4.2.</span> <span class="toc-text">Loading the Kernel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise4"><span class="toc-number">2.4.3.</span> <span class="toc-text">Exercise4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise5"><span class="toc-number">2.4.4.</span> <span class="toc-text">Exercise5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise6"><span class="toc-number">2.4.5.</span> <span class="toc-text">Exercise6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-3-the-kernel"><span class="toc-number">2.5.</span> <span class="toc-text">Part 3: The Kernel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise7"><span class="toc-number">2.5.1.</span> <span class="toc-text">Exercise7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#formatted-printing-to-the-console"><span class="toc-number">2.5.2.</span> <span class="toc-text">Formatted Printing to the Console</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise8"><span class="toc-number">2.5.3.</span> <span class="toc-text">Exercise8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-stack"><span class="toc-number">2.5.4.</span> <span class="toc-text">The Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise9"><span class="toc-number">2.5.5.</span> <span class="toc-text">Exercise9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise10"><span class="toc-number">2.5.6.</span> <span class="toc-text">Exercise10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise11"><span class="toc-number">2.5.7.</span> <span class="toc-text">Exercise11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise12"><span class="toc-number">2.5.8.</span> <span class="toc-text">Exercise12</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lab2-memory-management"><span class="toc-number">3.</span> <span class="toc-text">lab2: Memory Management</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://pic4.zhimg.com/80/v2-44243020fbff5630b343a4e92c3186fb_720w.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Risuxx's blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">MIT_6.828</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-11-16 18:03:27"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-11-16</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-01 20:30:07"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-01</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="简介">简介</h1>
<p>MIT6.828 Operating System Engineering</p>
<p>6.828的目标是：1. 理解操作系统设计和实现、2. 实现小型操作系统</p>
<p>OS的目的是：1. 支持应用程序运行、2. 对硬件进行抽象、3. 在多个应用程序之间复用硬件、4. 隔离应用程序防止bugs、5. 允许共用多个应用程序、6. 高性能</p>
<p>操作系统内核一般提供：进程、内存分配、file contents、目录和文件名、安全、以及其他的例如，用户，IPC，网络，计时，终端</p>
<p>操作系统的抽象让应用程序只看到系统调用。</p>
<p>我实验使用的是 ubuntu-16.04.6-desktop-i386</p>
<h1 id="lab1-booting-a-pc">Lab1: Booting a PC</h1>
<h2 id="introduction">Introduction</h2>
<p>这个实验分为三个部分。第一部分会专注于熟悉x86汇编语言、QEMU x86模拟器、PC的开机引导程序。第二部分检查了我们的6.828内核的引导程序，该引导程序位于lab树的boot文件夹中。最后，第三部分深入研究6.828内核的初始模板，我们把它叫做JOS，它位于kernel文件夹中。</p>
<h2 id="software-setup">Software Setup</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/6.828</span><br><span class="line">cd ~/6.828</span><br><span class="line">sudo apt-get install git</span><br><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br><span class="line">Cloning into lab...</span><br><span class="line">cd lab</span><br></pre></td></tr></table></figure>
<p>然后配置一下git，生成ssh密钥</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "ris.qscf@gmail.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/lin/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>然后登陆github打开Account settings -&gt; SSH Keys 点击Add SSH Key填上Title，在Key文本框里粘贴id_rsa.pub的文件内容[需要全部复制进去]。（/home/lin/.ssh/id_rsa.pub.）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/risuxx/JOS.git</span><br><span class="line">假如这一步出错则先输入 git remote rm origin</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>完成配置之后成功上传到github，由于该实验需要切换分支，而将remote库与自己的库绑定后无法切换分支，所以可以先不要这么做，等最终实验完成时再进行提交。</p>
<h3 id="simulating-the-x86">Simulating the x86</h3>
<p>在6.828中我们将使用 <a href="http://www.qemu.org/" target="_blank" rel="noopener">QEMU Emulator</a>。QEMU内建监视器只提供有限的debug支持，QEMU可以作为GDB的远程调试目标，我们将在这个lab中一步步的实现一个简单的启动程序。</p>
<p>首先我们安装qemu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure>
<p>然后编译我们的lab1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd lab</span><br><span class="line">make</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/16/MIT-6-828/image-20201117175916581.png" alt="image-20201117175916581" style="zoom:80%;"></p>
<p>假如需要在没有虚拟VGA的情况下使用串行控制台则输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu-nox</span><br></pre></td></tr></table></figure>
<p>如果需要退出qemu输入(注意需要在ubuntu的shell中输入)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+a x</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">K&gt;</span><span class="bash"> <span class="built_in">help</span></span></span><br><span class="line">help - display this list of commands</span><br><span class="line">kerninfo - display information about the kernel</span><br><span class="line"><span class="meta">K&gt;</span><span class="bash"> kerninfo</span></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f0101a75 (virt)  00101a75 (phys)</span><br><span class="line">  edata  f0112300 (virt)  00112300 (phys)</span><br><span class="line">  end    f0112960 (virt)  00112960 (phys)</span><br><span class="line">Kernel executable memory footprint: 75KB</span><br><span class="line"><span class="meta">K&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在只有两条命令：help用来查看有哪些命令、kerninfo用来展示kernel的信息。</p>
<p>如果将obj/kern/kernel.img的内容复制到真实的硬盘的前几个扇区中，并且在真实的PC中打开它，会看到和QEMU中相同的内容（但是不建议进行这样的操作，因为复制kernel.img进入硬盘的开头将会破坏主引导记录和第一个分区的开头，从而导致硬盘上的所有内容丢失。）</p>
<h2 id="rom-bios">ROM BIOS</h2>
<p>在本部分的实验中，您将使用QEMU的调试工具来研究IA-32兼容计算机的启动方式。</p>
<p>打开两个terminal窗口并且这两个shell都进入lab目录。在其中一个窗口中输入<code>make qemu-gdb(or make qemu-nox-gdb)</code>。这个操作会启动QEMU但是QEMU会在执行第一个指令之前停下来，并且等待与GDB的连接。在第二个terminal中，在同一个文件夹下需要执行<code>make</code>命令，然后执行<code>make gdb</code>。你应该会看到如下的样子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lin@lin-virtual-machine:~/6.828/lab$ make</span><br><span class="line">lin@lin-virtual-machine:~/6.828/lab$ make gdb</span><br><span class="line">gdb -n -x .gdbinit</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</span><br><span class="line">and "show warranty" for details.</span><br><span class="line">This GDB was configured as "i686-linux-gnu".</span><br><span class="line">Type "show configuration" for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type "help".</span><br><span class="line">Type "apropos word" to search for commands related to "word".</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration</span><br><span class="line">of GDB.  Attempting to continue with the default i8086 settings.</span><br><span class="line"></span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>我们提供了一个<code>.gdbinit</code>文件去设置GDB，让它在启动过程中去debug16位的代码，并且attach和监听QEMU。</p>
<p>下面的一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure>
<p>是GDB反汇编的第一个要被执行的命令。从这个输出中你可以确信一些事情：</p>
<ul>
<li>IBM的PC从物理地址<code>0x000ffff0</code>开始执行指令，这个地址是保留给ROM BIOS的64KB区域的头部。</li>
<li>PC开始执行的时候<code>CS = 0xf000</code>以及<code>IP = 0xfff0</code></li>
<li>第一个要被执行的指令是一个<code>jmp</code>指令，将要跳转到的地址是<code>CS = 0xf000</code>和<code>IP = 0xe05b</code></li>
</ul>
<p>为什么QEMU是像这样启动的？Intel是这样设计8088处理器的。因为在PC中BIOS是一个物理地址为<code>0x000f000-0x000fffff</code>的<strong>hard-wired</strong>，这个设计确保了BIOS总是能在机器重启之后被控制，因为在起电后RAM中没有可以被执行的软件代码。</p>
<h3 id="the-pcs-physical-address-space">The PC's Physical Address Space</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\</span><br><span class="line"></span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<h3 id="exercise2">Exercise2</h3>
<p>使用GDB的<code>si</code>指令去追踪几个BIOS执行的指令，并且尝试猜测它们在做什么。你可能想要看 <a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm" target="_blank" rel="noopener">Phil Storrs I/O Ports Description</a>或者其他的资料 <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">6.828 reference materials page</a>。不需要弄清楚所有的细节--只需要有一个大致的了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8 #go and check a 4-byte word at address 0xf6ac8</span><br><span class="line">[f000:e062]    0xfe062: jne    0xfd2e1</span><br><span class="line">[f000:e066]    0xfe066: xor    %dx,%dx</span><br><span class="line">[f000:e068]    0xfe068: mov    %dx,%ss  #set ss to zero</span><br><span class="line">[f000:e06a]    0xfe06a: mov    $0x7000,%esp #set %esp to 0x7000</span><br><span class="line">[f000:e070]    0xfe070: mov    $0xf34c2,%edx</span><br><span class="line">[f000:e076]    0xfe076: jmp    0xfd15c</span><br><span class="line">[f000:d15c]    0xfd15c: mov    %eax,%ecx</span><br><span class="line">[f000:d15f]    0xfd15f: cli</span><br><span class="line">[f000:d160]    0xfd160: cld</span><br><span class="line">[f000:d161]    0xfd161: mov    $0x8f,%eax</span><br><span class="line">[f000:d167]    0xfd167: out    %al,$0x70</span><br><span class="line">[f000:d169]    0xfd169: in     $0x71,%al</span><br><span class="line">[f000:d16b]    0xfd16b: in     $0x92,%al</span><br><span class="line">[f000:d16d]    0xfd16d: or     $0x2,%al</span><br><span class="line">[f000:d16f]    0xfd16f: out    %al,$0x92</span><br><span class="line">[f000:d171]    0xfd171: lidtw  %cs:0x6ab8</span><br><span class="line">[f000:d177]    0xfd177: lgdtw  %cs:0x6a74</span><br><span class="line">[f000:d17d]    0xfd17d: mov    %cr0,%eax</span><br><span class="line">[f000:d180]    0xfd180: or     $0x1,%eax</span><br><span class="line">[f000:d184]    0xfd184: mov    %eax,%cr0</span><br><span class="line">[f000:d187]    0xfd187: ljmpl  $0x8,$0xfd18f</span><br><span class="line">至此，通过一个长跳转进入保护模式，实模式结束。</span><br></pre></td></tr></table></figure>
<p><code>cli</code>屏蔽中断，<code>cld</code>控制字符流向，然后与IO设备交互进行一些初始化，打开A20，之后使用<code>lidtw</code>和<code>lgdtw</code>加载idtr gdtr寄存器用来管理中断向量表以及进程表。之后设置cr0寄存器进入实模式，长跳转到内核。</p>
<p>当BIOS运行的时候，它设置了一个中断描述表以及初始化了一些设备例如VGA显示器。此时你能在QEMU窗口看到"Starting SeaBIOS"的提示。</p>
<p>在初始化PCI总线和所有BIOS知道的核心设备之后，它会茶轴可以启动的设备例如floppy，硬盘驱动，CD-ROM。最终当它找到可启动的硬盘之后，BIOS会从硬盘中读取boot loader，并跳转到boot loader中。</p>
<h2 id="part-2-the-boot-loader">Part 2: The Boot Loader</h2>
<p>Floppy和硬盘被划分为512b的区域，被称为sectors（扇区）。一个扇区是磁盘的最小传输单元：每一次读写操作大小必须是一个或者更多扇区那么大，并且要按照扇区的边界对齐。假如磁盘是可启动的，第一个扇区被称为启动扇区，因为boot loader的代码位于这一区域。当BIOS寻找一个可启动的floppy或者硬盘，它会将512b的启动扇区装载到内存中放到<code>0x7c00-0x7dff</code>上，之后使用<code>jmp</code>指令设置CS:IP为<code>0000:7c00</code>来将控制权交给boot loader。</p>
<p>从CD-ROM上启动的能力在PC发展到很晚的时候才出现，结果是PC结构拥有了一个能够略微重想启动过程的机会。因此现代BIOS从CD-ROM中启动由一些复杂。CD-ROMS使用2048b作为一个扇区大小而不是512b。BIOS能够在转移控制权之前，从磁盘中装载更大的boot image到内存中（而不仅仅是一个扇区）。</p>
<p>但是在6.828中，我们使用传统的硬盘驱动启动方式，也就意味这我们的boot loader必须小于512b。boot loader由一个汇编语言源文件boot/boot.S和一个C源文件boot/main.c组成。boot loader必须有两个主要功能。</p>
<ol type="1">
<li>boot loader将处理器转换为32位保护模式，因为在实模式中软件只能访问1MB的物理空间。保护模式在<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">PC Assembly Language</a>的1.2.7和1.2.8节有简要描述。你必须理解在保护模式中段地址与物理地址的差异。</li>
<li>boot loader使用x86的IO指令访问IDE磁盘设备寄存器，从硬盘上直接读取内核。</li>
</ol>
<p>在你理解了boot loader的源码之后，看文件obj/boot/boot.asm。这个文件是boot loader的汇编形式。通过这个汇编文件可以更加情绪的看到所有的boot loader代码位于物理内存的哪个地方。另外obj/kern/kernel.asm包含了JOS内核的汇编代码，它在debugging的时候经常是很有用的。</p>
<h3 id="exercise3">Exercise3</h3>
<p>看一下 <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html" target="_blank" rel="noopener">lab tools guide</a>，特别是GDB命令的章节。即使你很熟悉GDB，这中间也包含了一些在OS中有用但是不常见的命令。</p>
<h4 id="gdb">GDB</h4>
<p><img src="/2020/11/16/MIT-6-828/image-20201118160738217.png" alt="image-20201118160738217" style="zoom:80%;"></p>
<p>在<code>0x7c00</code>处打断点，这个地址是boot sector被装载的地址。跟踪调试boot/boot.S使用obj/boot/boot.asm的代码去查看你调试到哪里了。使用<code>x/i</code>命令去比较反汇编的代码和原始的obj/boot/boot.asm中的代码的区别。</p>
<p>跟踪调试<code>boot/main.c</code>中的<code>bootmain()</code>，之后进入<code>readsect()</code>。辨别与<code>readsect()</code>中语句相关的汇编语句。之后跟踪剩下的<code>readsect()</code>并且回到<code>bootmain()</code>中，并且确定for循环的开始和结束，这个for循环会将内核剩余的部分从硬盘中读出。查看在loop循环结束之后什么代码将会执行，在那个位置打断点，继续到断点处。之后步出剩下的boot loader代码。</p>
<p>开启一个terminal执行<code>make qemu-gdb</code>然后在同一个文件夹下（lab下）执行<code>make gdb</code>。然后再gdb中设置断点<code>b *0x7c00</code>。代码的详细分析参考https://www.cnblogs.com/fatsheep9146/p/5115086.html</p>
<p>需要能够回答下面的问题：</p>
<ul>
<li><p>什么时候处理器开始执行32位代码？如何从16位跳转到的32位？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses </span><br><span class="line"># identical to their physical addresses, so that the </span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>将cr0寄存器最低位设置为1就能从16位转为32位模式，之后使用长跳转。</p></li>
<li><p>boot loader执行的最后一个命令是什么？内核被装载之后的第一个命令是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))(); <span class="comment">// 最后一个命令，该命令用来调用内核的第一个指令</span></span><br></pre></td></tr></table></figure>
<p>第一条指令位于/kern/entry.S文件中，第一句 <code>movw $0x1234, 0x472</code></p></li>
<li><p>内核的第一个命令在哪？</p>
<p>第一条指令位于/kern/entry.S文件中。</p></li>
<li><p>boot loader如何知道要从硬盘中读取多少扇区才能将内核从磁盘中取出？从哪里找到这个信息？</p>
<p>查找Program Header Table</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">inb</span><span class="params">(<span class="keyword">word</span> port)</span></span>; <span class="comment">// 从I/O端口读取一个字节</span></span><br><span class="line"><span class="comment">// 例如下面语句从0x1F7端口读入一个数字</span></span><br><span class="line">inb(<span class="number">0x1F7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="loading-the-kernel">Loading the Kernel</h3>
<h3 id="exercise4">Exercise4</h3>
<p>关于C语言的指针编程，最好的参考是Brian Kernighan和Dennis Ritchie写的<em><a href="https://github.com/huyubing/books-pdf/blob/master/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80(K%26R)%E6%B8%85%E6%99%B0%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noopener">The C Programming Language</a></em>(被称为“K&amp;R”)。</p>
<p>从K&amp;R中的5.1(指针和地址)读到5.5(字符指针和函数)。然后下载<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c" target="_blank" rel="noopener">pointer.c</a>，运行它，并确保您理解所有打印值的来源。特别是，确保您理解打印的第1行和第6行中的指针地址从哪里来，打印的第2行到第4行中的所有值是如何到达那里的，以及为什么在第5行中打印的值看起来是损坏的。</p>
<p>还有其他关于C中的指针的参考资料(例如，Ted Jensen的一个教程中大量引用了K&amp;R)，尽管不那么强烈推荐。</p>
<p>警告:除非你已经完全精通C语言，否则不要跳过甚至略读这篇阅读练习。如果您不能真正理解C中的指针，您将在随后的实验中遭受难以言表的痛苦和折磨，然后最终以艰难的方式理解它们。相信我们;你不会想知道“艰难之路”是什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointers.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">f(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];             <span class="comment">// 栈中的临时变量</span></span><br><span class="line">    <span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);  <span class="comment">// malloc会分配到heap中</span></span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	a[i] = <span class="number">100</span> + i;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;</span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;</span><br><span class="line">    *c = <span class="number">400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) c + <span class="number">1</span>);</span><br><span class="line">    *c = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="keyword">int</span> *) a + <span class="number">1</span>;</span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解boot/main.c，您需要知道ELF二进制文件是什么。当编译和链接一个C程序(比如JOS内核)时，编译器会将每个C源代码('. c')文件转换为一个对象('.o')文件，其中包含用硬件所需的二进制格式编码的汇编语言指令。然后链接器将所有已编译的目标文件组合成一个单一的二进制镜像，比如obj/kern/kernel，在这个例子中是一个ELF格式的二进制镜像，它代表“可执行和可链接格式”。</p>
<p>关于这种格式的完整信息可以在我们的<a href="https://pdos.csail.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">参考页面</a>的<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">ELF规范</a>中找到，但是您不需要在这个类中深入研究这种格式的细节。尽管整个格式非常强大和复杂，但大多数复杂的部分是为了支持共享库的动态加载，这在这个类中我们不会做。维基百科的页面有一个简短的描述。</p>
<p>在6.828中，您可以将ELF可执行文件看作是一个带有加载信息的头文件，后面是几个程序段，每个程序段是一个连续的代码块或数据，打算在指定的地址加载到内存中。引导加载程序不修改代码或数据;它将其加载到内存中并开始执行。</p>
<p>ELF二进制文件从一个固定长度的ELF头文件开始，然后是一个可变长度的程序头文件，其中列出了要加载的每个程序部分。这些ELF头文件的C定义在inc/ELF .h中。我们感兴趣的项目部分是:</p>
<ul>
<li>.text : 可执行指令</li>
<li>.rodata: 只读数据段,例如字符串常量。（但是，我们不会费心设置硬件来禁止写入。）</li>
<li>.data : 存放已经初始化的数据，例如初始化的全局变量例如<code>int x = 5;</code></li>
<li>.bss ： 存放未初始化的变量， 但是在ELF中只需要记录.bss的起始地址和长度。<code>Loader</code> and <code>program</code>必须自己将.bss段清零。</li>
</ul>
<p>通过下面的命令来检查内核可执行文件中所有部分的名称、大小和链接地址的完整列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -h obj/kern/kernel</span><br><span class="line">objdump -x obj/kern/kernel  # 该命令可以用来查看kernel的文件头</span><br></pre></td></tr></table></figure>
<p>BIOS从地址0x7c00开始将引导扇区加载到内存中，因此这是引导扇区的加载地址。这也是引导扇区执行的地方，所以这也是它的链接地址。我们通过将 <code>-Ttext 0x7C00</code>传递给boot/Makefrag中的链接器来设置链接地址，因此链接器将在生成的代码中生成正确的内存地址。</p>
<h3 id="exercise5">Exercise5</h3>
<p>再次跟踪引导加载程序的前几条指令，并确定第一条指令，如果引导加载程序的链接地址错误，它将“中断”或执行错误操作。然后将boot/Makefrag中的链接地址更改为错误，运行make clean，用make重新编译实验室，并再次跟踪引导加载程序，看看会发生什么。别忘了把链接地址改回来，然后make clean!</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201123145615676.png" alt="image-20201123145615676" style="zoom:80%;"></p>
<p>将0x7c00修改为0x7000，然后进行make clean</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201123150059759.png" alt="image-20201123150059759" style="zoom:80%;"></p>
<p>似乎没有发生什么事情，然后试着将链接地址改为0x7cc0之后启动的提示句子反复在屏幕中出现</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201123150410231.png" alt="image-20201123150410231" style="zoom:80%;"></p>
<p>回头看看内核的加载和链接地址。与引导加载程序不同，这两个地址并不相同:内核告诉引导加载程序以低地址(1兆字节)将其加载到内存中，但它期望从高地址执行。在下一节中，我们将深入研究如何使其工作。</p>
<p>除了片段信息之外，ELF头中还有一个对我们很重要的字段，即e_entry。这个字段保存程序入口点的链接地址:程序文本部分的内存地址，程序应该在这里开始执行。你可以看到入口点:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objdump -f obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br></pre></td></tr></table></figure>
<p>您现在应该能够理解boot/main.c中的最小ELF加载程序了。它将内核的每个部分从磁盘读入内存，读入该部分的加载地址，然后跳到内核的入口点。</p>
<h3 id="exercise6">Exercise6</h3>
<p>重置机器(退出QEMU/GDB并再次启动它们)。在BIOS进入引导加载程序时，然后在引导加载程序进入内核时，检查0x00100000处的8个单词的内存。为什么会有不同?第二个断点是什么?(您实际上并不需要使用QEMU来回答这个问题。只是觉得)。</p>
<p>在进入boot loader的时候都是0，因为此时还是在实模式，之后进入kernel的时候已经有值了。</p>
<h2 id="part-3-the-kernel">Part 3: The Kernel</h2>
<p>现在，我们将开始更详细地研究最小JOS内核。(您终于可以编写一些代码了!)与引导加载程序一样，内核从一些汇编语言代码开始，这些代码进行了设置，以便后面的C语言代码能够正确执行。</p>
<p><strong>使用虚拟内存来解决位置依赖</strong> 当您检查上面的引导加载程序的链接和加载地址时，它们完全匹配，但是内核的链接地址(由objdump打印)和它的加载地址之间存在(相当大的)差异。回去检查一下，确保你能明白我们在说什么。(链接内核比引导加载程序更复杂，因此链接地址和加载地址位于kern/kernel.ld的顶部。)</p>
<p>操作系统内核通常喜欢在非常高的虚拟地址(比如0xf0100000)上链接和运行，以便将处理器虚拟地址空间的较低部分留给用户程序使用。这样安排的原因在下一个实验室会更清楚。</p>
<p>许多机器在地址0xf0100000处没有任何物理内存，因此我们不能指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件来将虚拟地址0xf0100000(内核代码预期运行的链接地址)映射到物理地址0x00100000(引导加载程序将内核加载到物理内存的位置)。这种方式,虽然内核虚拟地址高的足以让很多用户进程的地址空间,它将被加载到物理内存中1 mb的电脑的内存,略高于BIOS芯片。这种方法要求个人电脑至少有几兆字节的物理内存(物理地址0 x00100000作品),但是这可能是真正的电脑大约1990之后建立的。</p>
<p>实际上，在下一个实验室中，我们将分别映射PC的整个底层256MB物理地址空间，从物理地址0x00000000到0x0fffffff，到虚拟地址0xf0000000到0xffffffff。现在您应该看到为什么JOS只能使用前256MB的物理内存。</p>
<p>现在，我们只映射前4MB的物理内存，这将足以让我们启动并运行。我们使用kern/entrypgdir.c中手工编写的静态初始化页目录和页表来完成此操作。现在，您不需要了解它的工作细节，只需要了解它所实现的效果。直到kern/条目。当设置CR0_PG标志时，内存引用被视为物理地址(严格地说，它们是线性地址，但是是引导/引导)。我们建立了一个从线性地址到物理地址的身份映射，我们永远不会改变它)。一旦设置了CR0_PG，内存引用就是虚拟地址，虚拟内存硬件会将其转换为物理地址。entry_pgdir将范围0xf0000000到0xf0400000的虚拟地址转换为物理地址0x00000000到0x00400000，以及虚拟地址0x00000000到0x00400000的物理地址0x00000000。任何不在这两个范围内的虚拟地址都将导致硬件异常，因为我们还没有设置中断处理，这将导致QEMU转储机器状态并退出(或者，如果不使用补丁版本为6.828的QEMU，则会无休止地重新启动)（这里应该就是之前练习中修改链接地址导致不断重新启动的原因，因为我没有使用补丁版本的QEMU）。</p>
<h3 id="exercise7">Exercise7</h3>
<p>使用QEMU和GDB跟踪jo内核，并在<code>movl %eax, %cr0</code>处停止。检查0x00100000和0xf0100000处的内存。现在，使用<code>stepi</code> GDB命令完成该指令的单步操作。同样，检查0x00100000和0xf0100000处的内存。确保你明白刚才发生了什么。</p>
<p>建立新映射后的第一条指令是什么?如果映射不到位，它将不能正常工作?注释掉内核/条目中的movl %eax， %cr0。追踪它，看看你是否猜对了。</p>
<p>首先启动qemu和gdb然后在<code>0x100025</code>处下断点，该地址就是<code>movl %eax, %cr0</code></p>
<p><img src="/2020/11/16/MIT-6-828/image-20201123152529929.png" alt="image-20201123152529929" style="zoom:80%;"></p>
<p>在注释movl %eax， %cr0之后执行$relocated有关的指令会出错，因为这个地址是段地址+偏移，如果没有映射那么段地址就是0xf0100008，而实际地址并没有这个地址。</p>
<h3 id="formatted-printing-to-the-console">Formatted Printing to the Console</h3>
<p>大多数人认为像printf()这样的函数是理所当然的，有时甚至认为它们是C语言的“原语”。但是在操作系统内核中，我们必须自己实现所有的I/O。</p>
<p>通读kern/printf.c，lib/printfmt.c和kern/console.c。确保你理解他们的关系。在以后的实验中，将会清楚为什么printfmt.c位于单独的lib目录中。</p>
<h3 id="exercise8">Exercise8</h3>
<p>我们省略了一小段代码——使用“%o”形式的模式打印八进制数所必需的代码。查找并填充此代码片段。</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201123164959689.png" alt="image-20201123164959689" style="zoom:80%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">		crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">	crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crt_pos:当前输出位置指针，指向内存区中对应输出映射地址。</p>
<p>CRT_SIZE:是CRT_COLS和CRT_ROWS的乘积，即2000=80*25，是不翻页时一页屏幕最大能容纳的字数</p>
<p>crt_buf:输出缓冲区内存映射地址</p>
<p>CRT_COLS:默认输出格式下整个屏幕的列数，为80</p>
<p>CRT_ROWS:默认输出格式下整个屏幕的行数，为25</p>
<p>unit16_t:typedef unsigned short 正好两字节，可以分别用来表示当前要打印的字符ASCII码和打印格式属性。</p>
<p>函数：</p>
<p>memmove(): memmove(void <em>dst, const void </em>src, size_t n).意为将从src指向位置起的n字节数据送到dst指向位置，可以在两个区域重叠时复制。</p>
<p>该功能是向下滚动一行。</p>
<h3 id="the-stack">The Stack</h3>
<p>在这个实验室的最后练习中,我们将更详细地探讨C语言的方式使用x86上的堆栈,并在这一过程中写一个有用的新内核监控功能,输出一个堆栈回溯:保存指令指针(IP)的列表值从嵌套调用指令导致的当前点执行。</p>
<h3 id="exercise9">Exercise9</h3>
<p>确定内核初始化其堆栈的位置，以及它的堆栈在内存中的确切位置。内核如何为它的堆栈保留空间?并且在这个保留区域的“结束”是堆栈指针初始化指向?</p>
<p>https://www.cnblogs.com/fatsheep9146/p/5079177.html</p>
<p>ebp(基指针)寄存器主要根据软件约定与堆栈相关联。在进入C函数时，函数的序言代码通常通过将前一个函数的基指针压入堆栈来保存它，然后在函数运行期间将当前的esp值复制到ebp中。如果所有的功能在程序遵守本公约,在任何给定的点在程序的执行期间,可以追溯链后通过堆栈保存ebp指针和决定什么嵌套的函数调用序列使这个程序中的特定点。此功能可能特别有用，例如，当某个特定函数由于传入了错误的参数而导致断言失败或恐慌时，但您不确定是谁传递了错误的参数。<strong>堆栈回溯</strong>让您找到出错的函数。</p>
<h3 id="exercise10">Exercise10</h3>
<p>要熟悉x86上的C调用约定，可以在obj/kern/kernel.asm中找到test_backtrace函数的地址。在那里设置一个断点，并检查在内核启动后每次调用断点时会发生什么。</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201124184714586.png" alt="image-20201124184714586" style="zoom:80%;"></p>
<p>https://blog.csdn.net/amgtgsh3150267/article/details/101834732</p>
<p>上面的练习应该为您提供实现堆栈回溯函数所需的信息，您应该调用mon_backtrace()。这个函数的原型已经在kern/monitor.c中等你了。您可以完全用C语言完成，但是您可能会发现inc/x86.h中的read_ebp()函数很有用。您还必须将这个新函数连接到内核监视器的命令列表中，以便用户可以交互地调用它。</p>
<p>backtrace函数应该以以下格式显示函数调用帧列表:</p>
<p>stack backtrace: ebp f0109e58 eip f0100a62 args 00000001 f0109e80 f0109e98 f0100ed2 00000031 ebp f0109ed8 eip f01000d6 args 00000000 00000000 f0100058 f0109f28 00000061 … 每行包含ebp、eip和args。 ebp值表示进入该函数使用的堆栈的基指针:在函数被输入和函数序言代码设置基指针后堆栈指针的位置。列出的eip值是函数的返回指令指针:当函数返回时，控件将返回的指令地址。rip通常指向<code>call</code>之后的一行的地址。最后，在args后面列出的5个十六进制值是所讨论的函数的前5个参数，它们将在调用函数之前被压入堆栈。当然，如果调用函数时参数少于5个，那么这5个值并不都有用。(为什么回溯代码不能检测实际有多少个参数?&lt;这个是因为在函数内部代码中需要使用ebp的值来定位参数的位置，假如传入更少的参数会使得难以定位&gt;这个限制是如何被修正的呢?&lt;可以在传递参数的时候同时传递参数的个数，例如main函数的声明&gt;)</p>
<p>打印的第一行反映当前执行的函数，即mon_backtrace本身，第二行反映调用mon_backtrace的函数，第三行反映调用该函数的函数，依此类推。您应该打印所有未完成的堆栈帧。通过研究kern/entry.S。你会发现有一个简单的方法告诉你什么时候停止。</p>
<p>以下是你在&lt;K&amp;R&gt;第5章中读到的一些要点，值得在接下来的练习和未来的实验中记住。</p>
<ul>
<li>如果<code>int * p = (int*)100</code>，那么<code>(int)p + 1</code>和<code>(int)(p + 1)</code>是不同的数字:第一个是101，第二个是104。在向指针添加整数时(如第二种情况)，该整数被隐式地乘以指针指向的对象的大小。</li>
<li><code>p[i]</code>被定义为与<code>*(p+i)</code>相同，指的是p指向的内存中的第i个对象。当对象大于一个字节时，上面的加法规则有助于这个定义。</li>
<li><code>&amp;p[i]</code>与<code>(p+i)</code>相同，产生内存中p指向的第i个对象的地址。 尽管大多数C程序从不需要在指针和整数之间进行转换，但操作系统经常需要。每当您看到一个涉及到内存地址的加法时，问问自己它是整数加法还是指针加法，并确保所添加的值是否被适当地相乘。</li>
</ul>
<h3 id="exercise11">Exercise11</h3>
<p>借助x86提供的read_ebp()在kern/monitor.c的mon_backtrace中打印出函数调用的栈中的ebp和eip的信息，实现前面提到的打印ebp eip args的效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="keyword">uint32_t</span> *ebp = (<span class="keyword">uint32_t</span> *)read_ebp(); <span class="comment">// get the value of ebp reg</span></span><br><span class="line">	<span class="keyword">uint32_t</span> eip = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">		eip = *(ebp+<span class="number">1</span>); <span class="comment">// the return addr&lt;eip&gt; is near the ebp</span></span><br><span class="line">		cprintf(<span class="string">"ebp %08x eip %08x args %08x %08x %08x %08x %08x\n"</span>, ebp, eip, *(ebp+<span class="number">2</span>), *(ebp+<span class="number">3</span>), *(ebp+<span class="number">4</span>), *(ebp+<span class="number">5</span>), *(ebp+<span class="number">6</span>));</span><br><span class="line">		ebp = (<span class="keyword">uint32_t</span> *)*ebp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/16/MIT-6-828/image-20201124204641734.png" alt="image-20201124204641734" style="zoom:80%;"></p>
<p>此时，您的backtrace函数应该为您提供导致执行mon_backtrace()的堆栈上的函数调用者的地址。但是，在实践中，您通常希望知道与这些地址对应的函数名。例如，您可能想知道哪些函数可能包含导致内核崩溃的错误。</p>
<p>为了帮助您实现此功能，我们提供了函数debuginfo_eip()，它在符号表中查找eip并返回该地址的调试信息。这个函数在kern/kdebug.c中定义。</p>
<h3 id="exercise12">Exercise12</h3>
<p>kern/kernel.ld中的<code>__STAB_*</code></p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201190846006.png" alt="image-20201201190846006" style="zoom:80%;"></p>
<p>分别指定了stab和stabstr段的起始和结束地址</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201191352796.png" alt="image-20201201191352796" style="zoom:80%;"></p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201191832700.png" alt="image-20201201191832700" style="zoom:80%;"></p>
<p>这里解释一下上面这个表的意思：</p>
<ul>
<li>Symnum是这个表的索引</li>
<li>n_type是符号的类型，SO 表示主函数的文件名，SOL 表示包含进的文件名，SLINE 表示代码段的行号，FUN 表示函数的名称</li>
<li>n_othr目前没被使用，其值固定为0</li>
<li>n_value表示的是地址。FUN类型中是绝对地址，SLINE的地址表示偏移量它的实际地址等于函数入口地址加上偏移量。</li>
</ul>
<p>查看init.s</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201192920590.png" alt="image-20201201192920590" style="zoom:80%;"></p>
<p>查看符号表在加载内存的时候有没有加载，根据前面的查看的信息可以看到.stabstr加载到了<code>0xf0105871</code>于是按照如下的方式查看</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201194616070.png" alt="image-20201201194616070" style="zoom:80%;"></p>
<p>我们需要利用stab的信息，/lab/kern/kdebug.c/stab_binsearch来找到某个地址对应的行号。我们需要通过插入对stab_binsearch的调用完成/lab/kern/kdebug.c/debuginfo_eip的实现。</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201201316983.png" alt="image-20201201201316983" style="zoom:80%;"></p>
<p>然后需要给内核添加backtrace命令，并且在mon_backtrace中添加打印文件名、函数名和行号的功能。</p>
<p>首先在kern/monitor.c中添加命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="keyword">uint32_t</span> *ebp = (<span class="keyword">uint32_t</span> *)read_ebp(); <span class="comment">// get the value of ebp reg</span></span><br><span class="line">	<span class="keyword">uint32_t</span> eip = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">		eip = *(ebp+<span class="number">1</span>); <span class="comment">// the return addr&lt;eip&gt; is near the ebp</span></span><br><span class="line">		cprintf(<span class="string">"ebp %08x eip %08x args %08x %08x %08x %08x %08x\n"</span>, ebp, eip, *(ebp+<span class="number">2</span>), *(ebp+<span class="number">3</span>), *(ebp+<span class="number">4</span>), *(ebp+<span class="number">5</span>), *(ebp+<span class="number">6</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Eipdebuginfo));</span><br><span class="line">		result = debuginfo_eip(eip, &amp;info);</span><br><span class="line">		<span class="keyword">if</span>(result)</span><br><span class="line">		&#123;</span><br><span class="line">			cprintf(<span class="string">"failed to get debuginfo for eip %x.\r\n"</span>, eip);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cprintf(<span class="string">"\t%s:%d %.*s+%u\r\n"</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ebp = (<span class="keyword">uint32_t</span> *)*ebp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际效果：</p>
<p><img src="/2020/11/16/MIT-6-828/image-20201201202638626.png" alt="image-20201201202638626" style="zoom:80%;"></p>
<p>printf("%.*s", length, string) prints at most length characters of string. 因此可以将函数名称后面的字符省略不打印。</p>
<h1 id="lab2-memory-management">lab2: Memory Management</h1>
<h1 id="参考资料">参考资料</h1>
<p>https://zhuanlan.zhihu.com/p/74028717</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Risuxx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://risuxx.github.io/2020/11/16/MIT-6-828/">https://risuxx.github.io/2020/11/16/MIT-6-828/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://risuxx.github.io" target="_blank">Risuxx's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/os/">os</a></div><div class="post_share"><div class="social-share" data-image="https://pic4.zhimg.com/80/v2-44243020fbff5630b343a4e92c3186fb_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/11/15/angr-ctf/"><img class="next_cover" src="https://pic3.zhimg.com/80/v2-c4fcb5062e8291d6adc3ff39f6f07b6e_720w.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">angr-ctf</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Risuxx</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>